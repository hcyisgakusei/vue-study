{"remainingRequest":"/Users/tech/workspace/demo/vue-demo/node_modules/babel-loader/lib/index.js!/Users/tech/workspace/demo/vue-demo/src/vueResource/core/vdom/helpers/merge-hook.js","dependencies":[{"path":"/Users/tech/workspace/demo/vue-demo/src/vueResource/core/vdom/helpers/merge-hook.js","mtime":1596452240000},{"path":"/Users/tech/workspace/demo/vue-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tech/workspace/demo/vue-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyogICAgICAgKi8KaW1wb3J0IFZOb2RlIGZyb20gJy4uL3Zub2RlJzsKaW1wb3J0IHsgY3JlYXRlRm5JbnZva2VyIH0gZnJvbSAnLi91cGRhdGUtbGlzdGVuZXJzJzsKaW1wb3J0IHsgcmVtb3ZlLCBpc0RlZiwgaXNVbmRlZiwgaXNUcnVlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWwnOwpleHBvcnQgZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2soZGVmLCBob29rS2V5LCBob29rKSB7CiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7CiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pOwogIH0KCiAgdmFyIGludm9rZXI7CiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07CgogIGZ1bmN0aW9uIHdyYXBwZWRIb29rKCkgewogICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlCiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVhawoKICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spOwogIH0KCiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHsKICAgIC8vIG5vIGV4aXN0aW5nIGhvb2sKICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7CiAgfSBlbHNlIHsKICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLwogICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7CiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlcgogICAgICBpbnZva2VyID0gb2xkSG9vazsKICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7CiAgICB9IGVsc2UgewogICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rCiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7CiAgICB9CiAgfQoKICBpbnZva2VyLm1lcmdlZCA9IHRydWU7CiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjsKfQ=="},{"version":3,"sources":["/Users/tech/workspace/demo/vue-demo/src/vueResource/core/vdom/helpers/merge-hook.js"],"names":["VNode","createFnInvoker","remove","isDef","isUndef","isTrue","mergeVNodeHook","def","hookKey","hook","data","invoker","oldHook","wrappedHook","apply","arguments","fns","merged","push"],"mappings":"AAAA;AAEA,OAAOA,KAAP,MAAkB,UAAlB;AACA,SAAQC,eAAR,QAA8B,oBAA9B;AACA,SAAQC,MAAR,EAAgBC,KAAhB,EAAuBC,OAAvB,EAAgCC,MAAhC,QAA6C,sBAA7C;AAEA,OAAO,SAASC,cAAT,CAAwBC,GAAxB,EAA6BC,OAA7B,EAAsCC,IAAtC,EAA4C;AACjD,MAAIF,GAAG,YAAYP,KAAnB,EAA0B;AACxBO,IAAAA,GAAG,GAAGA,GAAG,CAACG,IAAJ,CAASD,IAAT,KAAkBF,GAAG,CAACG,IAAJ,CAASD,IAAT,GAAgB,EAAlC,CAAN;AACD;;AACD,MAAIE,OAAJ;AACA,MAAMC,OAAO,GAAGL,GAAG,CAACC,OAAD,CAAnB;;AAEA,WAASK,WAAT,GAAuB;AACrBJ,IAAAA,IAAI,CAACK,KAAL,CAAW,IAAX,EAAiBC,SAAjB,EADqB,CAErB;AACA;;AACAb,IAAAA,MAAM,CAACS,OAAO,CAACK,GAAT,EAAcH,WAAd,CAAN;AACD;;AAED,MAAIT,OAAO,CAACQ,OAAD,CAAX,EAAsB;AACpB;AACAD,IAAAA,OAAO,GAAGV,eAAe,CAAC,CAACY,WAAD,CAAD,CAAzB;AACD,GAHD,MAGO;AACL;AACA,QAAIV,KAAK,CAACS,OAAO,CAACI,GAAT,CAAL,IAAsBX,MAAM,CAACO,OAAO,CAACK,MAAT,CAAhC,EAAkD;AAChD;AACAN,MAAAA,OAAO,GAAGC,OAAV;AACAD,MAAAA,OAAO,CAACK,GAAR,CAAYE,IAAZ,CAAiBL,WAAjB;AACD,KAJD,MAIO;AACL;AACAF,MAAAA,OAAO,GAAGV,eAAe,CAAC,CAACW,OAAD,EAAUC,WAAV,CAAD,CAAzB;AACD;AACF;;AAEDF,EAAAA,OAAO,CAACM,MAAR,GAAiB,IAAjB;AACAV,EAAAA,GAAG,CAACC,OAAD,CAAH,GAAeG,OAAf;AACD","sourcesContent":["/*       */\n\nimport VNode from '../vnode'\nimport {createFnInvoker} from './update-listeners'\nimport {remove, isDef, isUndef, isTrue} from '../../../shared/util'\n\nexport function mergeVNodeHook(def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {})\n  }\n  let invoker\n  const oldHook = def[hookKey]\n\n  function wrappedHook() {\n    hook.apply(this, arguments)\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook)\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook])\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook\n      invoker.fns.push(wrappedHook)\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook])\n    }\n  }\n\n  invoker.merged = true\n  def[hookKey] = invoker\n}\n"]}]}