{"remainingRequest":"/Users/tech/workspace/demo/vue-demo/node_modules/babel-loader/lib/index.js!/Users/tech/workspace/demo/vue-demo/src/vueResource/core/vdom/helpers/normalize-children.js","dependencies":[{"path":"/Users/tech/workspace/demo/vue-demo/src/vueResource/core/vdom/helpers/normalize-children.js","mtime":1596452135000},{"path":"/Users/tech/workspace/demo/vue-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tech/workspace/demo/vue-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKCi8qICAgICAgICovCmltcG9ydCBWTm9kZSwgeyBjcmVhdGVUZXh0Vk5vZGUgfSBmcm9tICcuLi8uLi8uLi9jb3JlL3Zkb20vdm5vZGUnOwppbXBvcnQgeyBpc0ZhbHNlLCBpc1RydWUsIGlzRGVmLCBpc1VuZGVmLCBpc1ByaW1pdGl2ZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlsJzsgLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5Ci8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuCi8vCi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlCi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmUKLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOgovLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50Ci8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGUKLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlCi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcAovLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uCgpleHBvcnQgZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHsKICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKTsKICAgIH0KICB9CgogIHJldHVybiBjaGlsZHJlbjsKfSAvLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLAovLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXIKLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvbgovLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy4KCmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikgewogIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbikgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV0gOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pIDogdW5kZWZpbmVkOwp9CgpmdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHsKICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KTsKfQoKZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHsKICB2YXIgcmVzID0gW107CiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDsKCiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICBjID0gY2hpbGRyZW5baV07CiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSBjb250aW51ZTsKICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxOwogICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdOyAvLyAgbmVzdGVkCgogICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHsKICAgICAgaWYgKGMubGVuZ3RoID4gMCkgewogICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICIiLmNvbmNhdChuZXN0ZWRJbmRleCB8fCAnJywgIl8iKS5jb25jYXQoaSkpOyAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzCgogICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHsKICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGNbMF0udGV4dCk7CiAgICAgICAgICBjLnNoaWZ0KCk7CiAgICAgICAgfQoKICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7CiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7CiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcwogICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmUKICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3MKICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTsKICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykgewogICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlCiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkgewogICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMKICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpCiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiYgaXNEZWYoYy50YWcpICYmIGlzVW5kZWYoYy5rZXkpICYmIGlzRGVmKG5lc3RlZEluZGV4KSkgewogICAgICAgICAgYy5rZXkgPSAiX192bGlzdCIuY29uY2F0KG5lc3RlZEluZGV4LCAiXyIpLmNvbmNhdChpLCAiX18iKTsKICAgICAgICB9CgogICAgICAgIHJlcy5wdXNoKGMpOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gcmVzOwp9"},{"version":3,"sources":["/Users/tech/workspace/demo/vue-demo/src/vueResource/core/vdom/helpers/normalize-children.js"],"names":["VNode","createTextVNode","isFalse","isTrue","isDef","isUndef","isPrimitive","simpleNormalizeChildren","children","i","length","Array","isArray","prototype","concat","apply","normalizeChildren","normalizeArrayChildren","undefined","isTextNode","node","text","isComment","nestedIndex","res","c","lastIndex","last","shift","push","_isVList","tag","key"],"mappings":"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","sourcesContent":["/*       */\n\nimport VNode, {createTextVNode} from '../../../core/vdom/vnode'\nimport {isFalse, isTrue, isDef, isUndef, isPrimitive} from '../../../shared/util'\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nexport function simpleNormalizeChildren(children) {\n  for (let i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nexport function normalizeChildren(children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  const res = []\n  let i, c, lastIndex, last\n  for (i = 0; i < children.length; i++) {\n    c = children[i]\n    if (isUndef(c) || typeof c === 'boolean') continue\n    lastIndex = res.length - 1\n    last = res[lastIndex]\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text)\n          c.shift()\n        }\n        res.push.apply(res, c)\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c)\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c))\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text)\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = `__vlist${nestedIndex}_${i}__`\n        }\n        res.push(c)\n      }\n    }\n  }\n  return res\n}\n"]}]}